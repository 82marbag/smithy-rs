/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0.
 */

//! Async functions that can be used to handle requests.
//!
//! For a function to be used as a handler it must implement the [`Handler`] trait.
//! We provide blanket implementations for functions that:
//!
//! - Are `async fn`s.
//! - Take one argument that can be converted (via [`std::convert::Into`]) into a type that
//!   implements [`FromRequest`].
//! - Returns a type that can be converted (via [`std::convert::Into`]) into a type that implements
//!   [`IntoResponse`].
//! - If a closure is used it must implement `Clone + Send` and be
//!   `'static`.
//! - Returns a future that is `Send`. The most common way to accidentally make a
//!   future `!Send` is to hold a `!Send` type across an await.

use async_trait::async_trait;
use axum::extract::{FromRequest, RequestParts};
use axum::response::IntoResponse;
use http::{Request, Response};
use std::future::Future;

use crate::body::{box_body, BoxBody};
use crate::extension::Extension;
use crate::model::*;

pub(crate) mod sealed {
    #![allow(unreachable_pub, missing_docs, missing_debug_implementations)]

    pub trait HiddenTrait {}
    pub struct Hidden;
    impl HiddenTrait for Hidden {}
}

#[async_trait]
pub trait Handler<B, I, Fut>: Clone + Send + Sized + 'static {
    #[doc(hidden)]
    type Sealed: sealed::HiddenTrait;

    async fn call(self, req: Request<B>) -> Response<BoxBody>;
}

// Implementations code-generated by smithy-rs below.

#[async_trait]
impl<B, Fun, Fut> Handler<B, (), HealthcheckInput> for Fun
where
    Fun: FnOnce(HealthcheckInput) -> Fut + Clone + Send + 'static,
    Fut: Future<Output = HealthcheckOutput> + Send,
    B: Send + 'static,
{
    type Sealed = sealed::Hidden;

    async fn call(self, _req: Request<B>) -> Response<BoxBody> {
        todo!()
    }
}

#[async_trait]
impl<B, Fun, Fut, S> Handler<B, Extension<S>, HealthcheckInput> for Fun
where
    Fun: FnOnce(HealthcheckInput, Extension<S>) -> Fut + Clone + Send + 'static,
    Fut: Future<Output = HealthcheckOutput> + Send,
    S: Send + Clone + Sync + 'static,
    B: Send + 'static,
{
    type Sealed = sealed::Hidden;

    async fn call(self, req: Request<B>) -> Response<BoxBody> {
        let mut req = RequestParts::new(req);

        let wrapper = match HealthcheckOperationInput::from_request(&mut req).await {
            Ok(value) => value,
            Err(rejection) => return rejection.into_response().map(box_body),
        };

        let state = match Extension::<S>::from_request(&mut req).await {
            Ok(value) => value,
            Err(rejection) => return rejection.into_response().map(box_body),
        };

        let input_inner = wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: HealthcheckOperationOutput = output_inner.into();

        output_wrapper.into_response().map(box_body)
    }
}

#[async_trait]
impl<B, Fun, Fut> Handler<B, (), RegisterServiceInput> for Fun
where
    Fun: FnOnce(RegisterServiceInput) -> Fut + Clone + Send + 'static,
    Fut: Future<Output = Result<RegisterServiceOutput, RegisterServiceError>> + Send,
    B: Send + 'static,
{
    type Sealed = sealed::Hidden;

    async fn call(self, req: Request<B>) -> Response<BoxBody> {
        let mut req = RequestParts::new(req);

        let wrapper = match RegisterServiceOperationInput::from_request(&mut req).await {
            Ok(value) => value,
            Err(rejection) => return rejection.into_response().map(box_body),
        };

        let input_inner = wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: RegisterServiceOperationOutput = output_inner.into();

        output_wrapper.into_response().map(box_body)
    }
}

#[async_trait]
impl<B, Fun, Fut, S> Handler<B, Extension<S>, RegisterServiceInput> for Fun
where
    Fun: FnOnce(RegisterServiceInput, Extension<S>) -> Fut + Clone + Send + 'static,
    Fut: Future<Output = RegisterServiceOutput> + Send,
    S: Send + Clone + Sync + 'static,
    B: Send + 'static,
{
    type Sealed = sealed::Hidden;

    async fn call(self, _req: Request<B>) -> Response<BoxBody> {
        todo!()
    }
}
