// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Struct that holds a handler, that is, a function provided by the user that implements the
/// Smithy operation.
pub struct OperationHandler<H, B, R, I> {
    handler: H,
    #[allow(clippy::type_complexity)]
    _marker: std::marker::PhantomData<fn() -> (B, R, I)>,
}
impl<H, B, R, I> Clone for OperationHandler<H, B, R, I>
where
    H: Clone,
{
    fn clone(&self) -> Self {
        Self {
            handler: self.handler.clone(),
            _marker: std::marker::PhantomData,
        }
    }
}
/// Construct an [`OperationHandler`] out of a function implementing the operation.
pub fn operation<H, B, R, I>(handler: H) -> OperationHandler<H, B, R, I> {
    OperationHandler {
        handler,
        _marker: std::marker::PhantomData,
    }
}
impl<H, B, R, I> tower::Service<http::Request<B>> for OperationHandler<H, B, R, I>
where
    H: Handler<B, R, I>,
    B: Send + 'static,
{
    type Response = http::Response<aws_smithy_http_server::BoxBody>;
    type Error = std::convert::Infallible;
    type Future = OperationHandlerFuture;

    #[inline]
    fn poll_ready(
        &mut self,
        _cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Result<(), Self::Error>> {
        std::task::Poll::Ready(Ok(()))
    }

    fn call(&mut self, req: http::Request<B>) -> Self::Future {
        use futures_util::FutureExt;
        let future =
            Handler::call(self.handler.clone(), req).map(Ok::<_, std::convert::Infallible> as _);
        OperationHandlerFuture::new(future)
    }
}
type WrapResultInResponseFn =
    fn(
        http::Response<aws_smithy_http_server::BoxBody>,
    ) -> Result<http::Response<aws_smithy_http_server::BoxBody>, std::convert::Infallible>;
use aws_smithy_http_server::opaque_future;
use pin_project;
opaque_future! {
    /// Response future for [`OperationHandler`].
    pub type OperationHandlerFuture =
        futures_util::future::Map<futures_util::future::BoxFuture<'static, http::Response<aws_smithy_http_server::BoxBody>>, WrapResultInResponseFn>;
}
pub(crate) mod sealed {
    #![allow(unreachable_pub, missing_docs, missing_debug_implementations)]
    pub trait HiddenTrait {}
    pub struct Hidden;
    impl HiddenTrait for Hidden {}
}
#[axum::async_trait]
pub trait Handler<B, T, Fut>: Clone + Send + Sized + 'static {
    #[doc(hidden)]
    type Sealed: sealed::HiddenTrait;

    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody>;
}
#[axum::async_trait]
impl<B, Fun, Fut> Handler<B, (), crate::input::CompleteSnapshotInput> for Fun
where
    Fun: FnOnce(crate::input::CompleteSnapshotInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<
            Output = Result<
                crate::output::CompleteSnapshotOutput,
                crate::error::CompleteSnapshotError,
            >,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum::extract::RequestParts::new(req);
        use axum::extract::FromRequest;
        use axum::response::IntoResponse;
        let input_wrapper =
            match crate::operation::CompleteSnapshotOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    return r
                        .into_response()
                        .map(aws_smithy_http_server::body::box_body)
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::CompleteSnapshotOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::body::box_body)
    }
}
#[axum::async_trait]
impl<B, Fun, Fut> Handler<B, (), crate::input::GetSnapshotBlockInput> for Fun
where
    Fun: FnOnce(crate::input::GetSnapshotBlockInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<
            Output = Result<
                crate::output::GetSnapshotBlockOutput,
                crate::error::GetSnapshotBlockError,
            >,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum::extract::RequestParts::new(req);
        use axum::extract::FromRequest;
        use axum::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetSnapshotBlockOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    return r
                        .into_response()
                        .map(aws_smithy_http_server::body::box_body)
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::GetSnapshotBlockOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::body::box_body)
    }
}
#[axum::async_trait]
impl<B, Fun, Fut> Handler<B, (), crate::input::ListChangedBlocksInput> for Fun
where
    Fun: FnOnce(crate::input::ListChangedBlocksInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<
            Output = Result<
                crate::output::ListChangedBlocksOutput,
                crate::error::ListChangedBlocksError,
            >,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum::extract::RequestParts::new(req);
        use axum::extract::FromRequest;
        use axum::response::IntoResponse;
        let input_wrapper =
            match crate::operation::ListChangedBlocksOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    return r
                        .into_response()
                        .map(aws_smithy_http_server::body::box_body)
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::ListChangedBlocksOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::body::box_body)
    }
}
#[axum::async_trait]
impl<B, Fun, Fut> Handler<B, (), crate::input::ListSnapshotBlocksInput> for Fun
where
    Fun: FnOnce(crate::input::ListSnapshotBlocksInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<
            Output = Result<
                crate::output::ListSnapshotBlocksOutput,
                crate::error::ListSnapshotBlocksError,
            >,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum::extract::RequestParts::new(req);
        use axum::extract::FromRequest;
        use axum::response::IntoResponse;
        let input_wrapper =
            match crate::operation::ListSnapshotBlocksOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    return r
                        .into_response()
                        .map(aws_smithy_http_server::body::box_body)
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::ListSnapshotBlocksOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::body::box_body)
    }
}
#[axum::async_trait]
impl<B, Fun, Fut> Handler<B, (), crate::input::PutSnapshotBlockInput> for Fun
where
    Fun: FnOnce(crate::input::PutSnapshotBlockInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<
            Output = Result<
                crate::output::PutSnapshotBlockOutput,
                crate::error::PutSnapshotBlockError,
            >,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum::extract::RequestParts::new(req);
        use axum::extract::FromRequest;
        use axum::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutSnapshotBlockOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    return r
                        .into_response()
                        .map(aws_smithy_http_server::body::box_body)
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::PutSnapshotBlockOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::body::box_body)
    }
}
#[axum::async_trait]
impl<B, Fun, Fut> Handler<B, (), crate::input::StartSnapshotInput> for Fun
where
    Fun: FnOnce(crate::input::StartSnapshotInput) -> Fut + Clone + Send + 'static,
    Fut: std::future::Future<
            Output = Result<crate::output::StartSnapshotOutput, crate::error::StartSnapshotError>,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum::extract::RequestParts::new(req);
        use axum::extract::FromRequest;
        use axum::response::IntoResponse;
        let input_wrapper =
            match crate::operation::StartSnapshotOperationInputWrapper::from_request(&mut req).await
            {
                Ok(v) => v,
                Err(r) => {
                    return r
                        .into_response()
                        .map(aws_smithy_http_server::body::box_body)
                }
            };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: crate::operation::StartSnapshotOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::body::box_body)
    }
}
#[axum::async_trait]
impl<B, Fun, Fut, S>
    Handler<B, aws_smithy_http_server::Extension<S>, crate::input::CompleteSnapshotInput> for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::CompleteSnapshotInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<
            Output = Result<
                crate::output::CompleteSnapshotOutput,
                crate::error::CompleteSnapshotError,
            >,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum::extract::RequestParts::new(req);
        use axum::extract::FromRequest;
        use axum::response::IntoResponse;
        let input_wrapper =
            match crate::operation::CompleteSnapshotOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    return r
                        .into_response()
                        .map(aws_smithy_http_server::body::box_body)
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                return r
                    .into_response()
                    .map(aws_smithy_http_server::body::box_body)
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::CompleteSnapshotOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::body::box_body)
    }
}
#[axum::async_trait]
impl<B, Fun, Fut, S>
    Handler<B, aws_smithy_http_server::Extension<S>, crate::input::GetSnapshotBlockInput> for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::GetSnapshotBlockInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<
            Output = Result<
                crate::output::GetSnapshotBlockOutput,
                crate::error::GetSnapshotBlockError,
            >,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum::extract::RequestParts::new(req);
        use axum::extract::FromRequest;
        use axum::response::IntoResponse;
        let input_wrapper =
            match crate::operation::GetSnapshotBlockOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    return r
                        .into_response()
                        .map(aws_smithy_http_server::body::box_body)
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                return r
                    .into_response()
                    .map(aws_smithy_http_server::body::box_body)
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::GetSnapshotBlockOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::body::box_body)
    }
}
#[axum::async_trait]
impl<B, Fun, Fut, S>
    Handler<B, aws_smithy_http_server::Extension<S>, crate::input::ListChangedBlocksInput> for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::ListChangedBlocksInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<
            Output = Result<
                crate::output::ListChangedBlocksOutput,
                crate::error::ListChangedBlocksError,
            >,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum::extract::RequestParts::new(req);
        use axum::extract::FromRequest;
        use axum::response::IntoResponse;
        let input_wrapper =
            match crate::operation::ListChangedBlocksOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    return r
                        .into_response()
                        .map(aws_smithy_http_server::body::box_body)
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                return r
                    .into_response()
                    .map(aws_smithy_http_server::body::box_body)
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::ListChangedBlocksOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::body::box_body)
    }
}
#[axum::async_trait]
impl<B, Fun, Fut, S>
    Handler<B, aws_smithy_http_server::Extension<S>, crate::input::ListSnapshotBlocksInput> for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::ListSnapshotBlocksInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<
            Output = Result<
                crate::output::ListSnapshotBlocksOutput,
                crate::error::ListSnapshotBlocksError,
            >,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum::extract::RequestParts::new(req);
        use axum::extract::FromRequest;
        use axum::response::IntoResponse;
        let input_wrapper =
            match crate::operation::ListSnapshotBlocksOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    return r
                        .into_response()
                        .map(aws_smithy_http_server::body::box_body)
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                return r
                    .into_response()
                    .map(aws_smithy_http_server::body::box_body)
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::ListSnapshotBlocksOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::body::box_body)
    }
}
#[axum::async_trait]
impl<B, Fun, Fut, S>
    Handler<B, aws_smithy_http_server::Extension<S>, crate::input::PutSnapshotBlockInput> for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::PutSnapshotBlockInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<
            Output = Result<
                crate::output::PutSnapshotBlockOutput,
                crate::error::PutSnapshotBlockError,
            >,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum::extract::RequestParts::new(req);
        use axum::extract::FromRequest;
        use axum::response::IntoResponse;
        let input_wrapper =
            match crate::operation::PutSnapshotBlockOperationInputWrapper::from_request(&mut req)
                .await
            {
                Ok(v) => v,
                Err(r) => {
                    return r
                        .into_response()
                        .map(aws_smithy_http_server::body::box_body)
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                return r
                    .into_response()
                    .map(aws_smithy_http_server::body::box_body)
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::PutSnapshotBlockOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::body::box_body)
    }
}
#[axum::async_trait]
impl<B, Fun, Fut, S>
    Handler<B, aws_smithy_http_server::Extension<S>, crate::input::StartSnapshotInput> for Fun
where
    S: Send + Clone + Sync + 'static,
    Fun: FnOnce(crate::input::StartSnapshotInput, aws_smithy_http_server::Extension<S>) -> Fut
        + Clone
        + Send
        + 'static,
    Fut: std::future::Future<
            Output = Result<crate::output::StartSnapshotOutput, crate::error::StartSnapshotError>,
        > + Send,
    B: aws_smithy_http_server::HttpBody + Send + 'static,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = sealed::Hidden;
    async fn call(self, req: http::Request<B>) -> http::Response<aws_smithy_http_server::BoxBody> {
        let mut req = axum::extract::RequestParts::new(req);
        use axum::extract::FromRequest;
        use axum::response::IntoResponse;
        let input_wrapper =
            match crate::operation::StartSnapshotOperationInputWrapper::from_request(&mut req).await
            {
                Ok(v) => v,
                Err(r) => {
                    return r
                        .into_response()
                        .map(aws_smithy_http_server::body::box_body)
                }
            };
        let state = match aws_smithy_http_server::Extension::<S>::from_request(&mut req).await {
            Ok(v) => v,
            Err(r) => {
                return r
                    .into_response()
                    .map(aws_smithy_http_server::body::box_body)
            }
        };
        let input_inner = input_wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: crate::operation::StartSnapshotOperationOutputWrapper =
            output_inner.into();
        output_wrapper
            .into_response()
            .map(aws_smithy_http_server::body::box_body)
    }
}
