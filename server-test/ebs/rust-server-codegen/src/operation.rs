// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Operation shape for `CompleteSnapshot`.
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CompleteSnapshot {
    _private: (),
}
impl CompleteSnapshot {
    /// Creates a new `CompleteSnapshot` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
pub(crate) struct CompleteSnapshotOperationInputWrapper(crate::input::CompleteSnapshotInput);
#[axum::async_trait]
impl<B> axum::extract::FromRequest<B> for CompleteSnapshotOperationInputWrapper
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Rejection = aws_smithy_http_server::rejection::SmithyRejection;
    async fn from_request(
        req: &mut axum::extract::RequestParts<B>,
    ) -> Result<Self, Self::Rejection> {
        aws_smithy_http_server::protocols::check_json_content_type(req)?;
        Ok(CompleteSnapshotOperationInputWrapper(
            crate::operation_deser::parse_complete_snapshot_request(req).await?,
        ))
    }
}
pub(crate) enum CompleteSnapshotOperationOutputWrapper {
    Output(crate::output::CompleteSnapshotOutput),
    Error(crate::error::CompleteSnapshotError),
}
#[axum::async_trait]
impl axum::response::IntoResponse for CompleteSnapshotOperationOutputWrapper {
    type Body = aws_smithy_http_server::Body;
    type BodyError = <Self::Body as aws_smithy_http_server::HttpBody>::Error;

    fn into_response(self) -> http::Response<Self::Body> {
        match self {
            Self::Output(o) => {
                match crate::operation_ser::serialize_complete_snapshot_response(&o) {
                    Ok(response) => response,
                    Err(e) => http::Response::builder()
                        .body(Self::Body::from(e.to_string()))
                        .expect("unable to build response from output"),
                }
            }
            Self::Error(err) => {
                match crate::operation_ser::serialize_complete_snapshot_error(&err) {
                    Ok(response) => response,
                    Err(e) => http::Response::builder()
                        .body(Self::Body::from(e.to_string()))
                        .expect("unable to build response from error"),
                }
            }
        }
    }
}
impl From<Result<crate::output::CompleteSnapshotOutput, crate::error::CompleteSnapshotError>>
    for CompleteSnapshotOperationOutputWrapper
{
    fn from(
        res: Result<crate::output::CompleteSnapshotOutput, crate::error::CompleteSnapshotError>,
    ) -> Self {
        match res {
            Ok(v) => Self::Output(v),
            Err(e) => Self::Error(e),
        }
    }
}
impl From<CompleteSnapshotOperationInputWrapper> for crate::input::CompleteSnapshotInput {
    fn from(i: CompleteSnapshotOperationInputWrapper) -> Self {
        i.0
    }
}

/// Operation shape for `GetSnapshotBlock`.
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetSnapshotBlock {
    _private: (),
}
impl GetSnapshotBlock {
    /// Creates a new `GetSnapshotBlock` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
pub(crate) struct GetSnapshotBlockOperationInputWrapper(crate::input::GetSnapshotBlockInput);
#[axum::async_trait]
impl<B> axum::extract::FromRequest<B> for GetSnapshotBlockOperationInputWrapper
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Rejection = aws_smithy_http_server::rejection::SmithyRejection;
    async fn from_request(
        req: &mut axum::extract::RequestParts<B>,
    ) -> Result<Self, Self::Rejection> {
        aws_smithy_http_server::protocols::check_json_content_type(req)?;
        Ok(GetSnapshotBlockOperationInputWrapper(
            crate::operation_deser::parse_get_snapshot_block_request(req).await?,
        ))
    }
}
pub(crate) enum GetSnapshotBlockOperationOutputWrapper {
    Output(crate::output::GetSnapshotBlockOutput),
    Error(crate::error::GetSnapshotBlockError),
}
#[axum::async_trait]
impl axum::response::IntoResponse for GetSnapshotBlockOperationOutputWrapper {
    type Body = aws_smithy_http_server::Body;
    type BodyError = <Self::Body as aws_smithy_http_server::HttpBody>::Error;

    fn into_response(self) -> http::Response<Self::Body> {
        todo!("Streaming support for output shapes is not yet supported in `smithy-rs`")
    }
}
impl From<Result<crate::output::GetSnapshotBlockOutput, crate::error::GetSnapshotBlockError>>
    for GetSnapshotBlockOperationOutputWrapper
{
    fn from(
        res: Result<crate::output::GetSnapshotBlockOutput, crate::error::GetSnapshotBlockError>,
    ) -> Self {
        match res {
            Ok(v) => Self::Output(v),
            Err(e) => Self::Error(e),
        }
    }
}
impl From<GetSnapshotBlockOperationInputWrapper> for crate::input::GetSnapshotBlockInput {
    fn from(i: GetSnapshotBlockOperationInputWrapper) -> Self {
        i.0
    }
}

/// Operation shape for `ListChangedBlocks`.
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListChangedBlocks {
    _private: (),
}
impl ListChangedBlocks {
    /// Creates a new `ListChangedBlocks` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
pub(crate) struct ListChangedBlocksOperationInputWrapper(crate::input::ListChangedBlocksInput);
#[axum::async_trait]
impl<B> axum::extract::FromRequest<B> for ListChangedBlocksOperationInputWrapper
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Rejection = aws_smithy_http_server::rejection::SmithyRejection;
    async fn from_request(
        req: &mut axum::extract::RequestParts<B>,
    ) -> Result<Self, Self::Rejection> {
        aws_smithy_http_server::protocols::check_json_content_type(req)?;
        Ok(ListChangedBlocksOperationInputWrapper(
            crate::operation_deser::parse_list_changed_blocks_request(req).await?,
        ))
    }
}
pub(crate) enum ListChangedBlocksOperationOutputWrapper {
    Output(crate::output::ListChangedBlocksOutput),
    Error(crate::error::ListChangedBlocksError),
}
#[axum::async_trait]
impl axum::response::IntoResponse for ListChangedBlocksOperationOutputWrapper {
    type Body = aws_smithy_http_server::Body;
    type BodyError = <Self::Body as aws_smithy_http_server::HttpBody>::Error;

    fn into_response(self) -> http::Response<Self::Body> {
        match self {
            Self::Output(o) => {
                match crate::operation_ser::serialize_list_changed_blocks_response(&o) {
                    Ok(response) => response,
                    Err(e) => http::Response::builder()
                        .body(Self::Body::from(e.to_string()))
                        .expect("unable to build response from output"),
                }
            }
            Self::Error(err) => {
                match crate::operation_ser::serialize_list_changed_blocks_error(&err) {
                    Ok(response) => response,
                    Err(e) => http::Response::builder()
                        .body(Self::Body::from(e.to_string()))
                        .expect("unable to build response from error"),
                }
            }
        }
    }
}
impl From<Result<crate::output::ListChangedBlocksOutput, crate::error::ListChangedBlocksError>>
    for ListChangedBlocksOperationOutputWrapper
{
    fn from(
        res: Result<crate::output::ListChangedBlocksOutput, crate::error::ListChangedBlocksError>,
    ) -> Self {
        match res {
            Ok(v) => Self::Output(v),
            Err(e) => Self::Error(e),
        }
    }
}
impl From<ListChangedBlocksOperationInputWrapper> for crate::input::ListChangedBlocksInput {
    fn from(i: ListChangedBlocksOperationInputWrapper) -> Self {
        i.0
    }
}

/// Operation shape for `ListSnapshotBlocks`.
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListSnapshotBlocks {
    _private: (),
}
impl ListSnapshotBlocks {
    /// Creates a new `ListSnapshotBlocks` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
pub(crate) struct ListSnapshotBlocksOperationInputWrapper(crate::input::ListSnapshotBlocksInput);
#[axum::async_trait]
impl<B> axum::extract::FromRequest<B> for ListSnapshotBlocksOperationInputWrapper
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Rejection = aws_smithy_http_server::rejection::SmithyRejection;
    async fn from_request(
        req: &mut axum::extract::RequestParts<B>,
    ) -> Result<Self, Self::Rejection> {
        aws_smithy_http_server::protocols::check_json_content_type(req)?;
        Ok(ListSnapshotBlocksOperationInputWrapper(
            crate::operation_deser::parse_list_snapshot_blocks_request(req).await?,
        ))
    }
}
pub(crate) enum ListSnapshotBlocksOperationOutputWrapper {
    Output(crate::output::ListSnapshotBlocksOutput),
    Error(crate::error::ListSnapshotBlocksError),
}
#[axum::async_trait]
impl axum::response::IntoResponse for ListSnapshotBlocksOperationOutputWrapper {
    type Body = aws_smithy_http_server::Body;
    type BodyError = <Self::Body as aws_smithy_http_server::HttpBody>::Error;

    fn into_response(self) -> http::Response<Self::Body> {
        match self {
            Self::Output(o) => {
                match crate::operation_ser::serialize_list_snapshot_blocks_response(&o) {
                    Ok(response) => response,
                    Err(e) => http::Response::builder()
                        .body(Self::Body::from(e.to_string()))
                        .expect("unable to build response from output"),
                }
            }
            Self::Error(err) => {
                match crate::operation_ser::serialize_list_snapshot_blocks_error(&err) {
                    Ok(response) => response,
                    Err(e) => http::Response::builder()
                        .body(Self::Body::from(e.to_string()))
                        .expect("unable to build response from error"),
                }
            }
        }
    }
}
impl From<Result<crate::output::ListSnapshotBlocksOutput, crate::error::ListSnapshotBlocksError>>
    for ListSnapshotBlocksOperationOutputWrapper
{
    fn from(
        res: Result<crate::output::ListSnapshotBlocksOutput, crate::error::ListSnapshotBlocksError>,
    ) -> Self {
        match res {
            Ok(v) => Self::Output(v),
            Err(e) => Self::Error(e),
        }
    }
}
impl From<ListSnapshotBlocksOperationInputWrapper> for crate::input::ListSnapshotBlocksInput {
    fn from(i: ListSnapshotBlocksOperationInputWrapper) -> Self {
        i.0
    }
}

/// Operation shape for `PutSnapshotBlock`.
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutSnapshotBlock {
    _private: (),
}
impl PutSnapshotBlock {
    /// Creates a new `PutSnapshotBlock` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
pub(crate) struct PutSnapshotBlockOperationInputWrapper(crate::input::PutSnapshotBlockInput);
#[axum::async_trait]
impl<B> axum::extract::FromRequest<B> for PutSnapshotBlockOperationInputWrapper
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Rejection = aws_smithy_http_server::rejection::SmithyRejection;
    async fn from_request(
        _req: &mut axum::extract::RequestParts<B>,
    ) -> Result<Self, Self::Rejection> {
        todo!("Streaming support for input shapes is not yet supported in `smithy-rs`")
    }
}
pub(crate) enum PutSnapshotBlockOperationOutputWrapper {
    Output(crate::output::PutSnapshotBlockOutput),
    Error(crate::error::PutSnapshotBlockError),
}
#[axum::async_trait]
impl axum::response::IntoResponse for PutSnapshotBlockOperationOutputWrapper {
    type Body = aws_smithy_http_server::Body;
    type BodyError = <Self::Body as aws_smithy_http_server::HttpBody>::Error;

    fn into_response(self) -> http::Response<Self::Body> {
        match self {
            Self::Output(o) => {
                match crate::operation_ser::serialize_put_snapshot_block_response(&o) {
                    Ok(response) => response,
                    Err(e) => http::Response::builder()
                        .body(Self::Body::from(e.to_string()))
                        .expect("unable to build response from output"),
                }
            }
            Self::Error(err) => {
                match crate::operation_ser::serialize_put_snapshot_block_error(&err) {
                    Ok(response) => response,
                    Err(e) => http::Response::builder()
                        .body(Self::Body::from(e.to_string()))
                        .expect("unable to build response from error"),
                }
            }
        }
    }
}
impl From<Result<crate::output::PutSnapshotBlockOutput, crate::error::PutSnapshotBlockError>>
    for PutSnapshotBlockOperationOutputWrapper
{
    fn from(
        res: Result<crate::output::PutSnapshotBlockOutput, crate::error::PutSnapshotBlockError>,
    ) -> Self {
        match res {
            Ok(v) => Self::Output(v),
            Err(e) => Self::Error(e),
        }
    }
}
impl From<PutSnapshotBlockOperationInputWrapper> for crate::input::PutSnapshotBlockInput {
    fn from(i: PutSnapshotBlockOperationInputWrapper) -> Self {
        i.0
    }
}

/// Operation shape for `StartSnapshot`.
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartSnapshot {
    _private: (),
}
impl StartSnapshot {
    /// Creates a new `StartSnapshot` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
pub(crate) struct StartSnapshotOperationInputWrapper(crate::input::StartSnapshotInput);
#[axum::async_trait]
impl<B> axum::extract::FromRequest<B> for StartSnapshotOperationInputWrapper
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Rejection = aws_smithy_http_server::rejection::SmithyRejection;
    async fn from_request(
        req: &mut axum::extract::RequestParts<B>,
    ) -> Result<Self, Self::Rejection> {
        aws_smithy_http_server::protocols::check_json_content_type(req)?;
        Ok(StartSnapshotOperationInputWrapper(
            crate::operation_deser::parse_start_snapshot_request(req).await?,
        ))
    }
}
pub(crate) enum StartSnapshotOperationOutputWrapper {
    Output(crate::output::StartSnapshotOutput),
    Error(crate::error::StartSnapshotError),
}
#[axum::async_trait]
impl axum::response::IntoResponse for StartSnapshotOperationOutputWrapper {
    type Body = aws_smithy_http_server::Body;
    type BodyError = <Self::Body as aws_smithy_http_server::HttpBody>::Error;

    fn into_response(self) -> http::Response<Self::Body> {
        match self {
            Self::Output(o) => match crate::operation_ser::serialize_start_snapshot_response(&o) {
                Ok(response) => response,
                Err(e) => http::Response::builder()
                    .body(Self::Body::from(e.to_string()))
                    .expect("unable to build response from output"),
            },
            Self::Error(err) => match crate::operation_ser::serialize_start_snapshot_error(&err) {
                Ok(response) => response,
                Err(e) => http::Response::builder()
                    .body(Self::Body::from(e.to_string()))
                    .expect("unable to build response from error"),
            },
        }
    }
}
impl From<Result<crate::output::StartSnapshotOutput, crate::error::StartSnapshotError>>
    for StartSnapshotOperationOutputWrapper
{
    fn from(
        res: Result<crate::output::StartSnapshotOutput, crate::error::StartSnapshotError>,
    ) -> Self {
        match res {
            Ok(v) => Self::Output(v),
            Err(e) => Self::Error(e),
        }
    }
}
impl From<StartSnapshotOperationInputWrapper> for crate::input::StartSnapshotInput {
    fn from(i: StartSnapshotOperationInputWrapper) -> Self {
        i.0
    }
}
